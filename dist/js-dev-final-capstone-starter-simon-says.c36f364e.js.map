{"mappings":"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","sources":["index.js"],"sourcesContent":["/**\r\n * DOM SELECTORS\r\n */\r\nconst sound1 = \"./assets/simon-says-sound-1.mp3\";\r\nconst sound2 = \"./assets/simon-says-sound-2.mp3\";\r\nconst sound3 = \"./assets/simon-says-sound-3.mp3\";\r\nconst sound4 = \"./assets/simon-says-sound-4.mp3\";\r\n\r\n const startButton = document.querySelector(\".js-start-button\");\r\n // TODO: Add the missing query selectors:\r\n const statusSpan = document.querySelector(\".js-status\"); // Use querySelector() to get the status element\r\n const heading = document.querySelector(\".js-heading\"); // Use querySelector() to get the heading element\r\n const padContainer = document.querySelector(\".js-pad-container\"); // Use querySelector() to get the heading element\r\n\r\n/**\r\n * VARIABLES\r\n */\r\nlet computerSequence = []; // track the computer-generated sequence of pad presses\r\nlet playerSequence = []; // track the player-generated sequence of pad presses\r\nlet maxRoundCount = 0; // the max number of rounds, varies with the chosen level\r\nlet roundCount = 0; // track the number of rounds that have been played so far\r\n\r\n/**\r\n *\r\n * The `pads` array contains an array of pad objects.\r\n *\r\n * Each pad object contains the data related to a pad: `color`, `sound`, and `selector`.\r\n * - The `color` property is set to the color of the pad (e.g., \"red\", \"blue\").\r\n * - The `selector` property is set to the DOM selector for the pad.\r\n * - The `sound` property is set to an audio file using the Audio() constructor.\r\n *\r\n * Audio file for the green pad: \"../assets/simon-says-sound-2.mp3\"\r\n * Audio file for the blue pad: \"../assets/simon-says-sound-3.mp3\"\r\n * Audio file for the yellow pad: \"../assets/simon-says-sound-4.mp3\"\r\n *\r\n */\r\n\r\n const pads = [\r\n  {\r\n    color: \"red\",\r\n    selector: document.querySelector(\".js-pad-red\"),\r\n    sound: new Audio(sound1),\r\n  },\r\n  // TODO: Add the objects for the green, blue, and yellow pads. Use object for the red pad above as an example.\r\n  {\r\n    color:\"blue\",\r\n    selector: document.querySelector(\".js-pad-blue\"),\r\n    sound: new Audio(sound3)\r\n  },\r\n  {\r\n    color: \"green\",\r\n    selector: document.querySelector(\".js-pad-green\"),\r\n    sound: new Audio(sound2)\r\n  },\r\n  {\r\n    color: \"yellow\",\r\n    selector: document.querySelector(\".js-pad-yellow\"),\r\n    sound: new Audio(sound4)\r\n  }\r\n];\r\n\r\n/**\r\n * EVENT LISTENERS\r\n */\r\n\r\npadContainer.addEventListener(\"click\", padHandler);\r\n// TODO: Add an event listener `startButtonHandler()` to startButton.\r\nstartButton.addEventListener(\"click\", startButtonHandler)\r\n/**\r\n * EVENT HANDLERS\r\n */\r\n\r\n/**\r\n * Called when the start button is clicked.\r\n *\r\n * 1. Call setLevel() to set the level of the game\r\n *\r\n * 2. Increment the roundCount from 0 to 1\r\n *\r\n * 3. Hide the start button by adding the `.hidden` class to the start button\r\n *\r\n * 4. Unhide the status element, which displays the status messages, by removing the `.hidden` class\r\n *\r\n * 5. Call `playComputerTurn()` to start the game with the computer going first.\r\n *\r\n */\r\nfunction startButtonHandler() {\r\n  // TODO: Write your code here.\r\n    maxRoundCount = setLevel();\r\n    roundCount = 1;\r\n    playComputerTurn();\r\n    startButton.classList.add(\"hidden\");\r\n    statusSpan.classList.remove(\"hidden\");\r\n  return { startButton, statusSpan };\r\n}\r\n\r\n/**\r\n * Called when one of the pads is clicked.\r\n *\r\n * 1. `const { color } = event.target.dataset;` extracts the value of `data-color`\r\n * attribute on the element that was clicked and stores it in the `color` variable\r\n *\r\n * 2. `if (!color) return;` exits the function if the `color` variable is falsy\r\n *\r\n * 3. Use the `.find()` method to retrieve the pad from the `pads` array and store it\r\n * in a variable called `pad`\r\n *\r\n * 4. Play the sound for the pad by calling `pad.sound.play()`\r\n *\r\n * 5. Call `checkPress(color)` to verify the player's selection\r\n *\r\n * 6. Return the `color` variable as the output\r\n */\r\nfunction padHandler(event) {\r\n  const { color } = event.target.dataset;\r\n  if (!color) return;\r\n  const pad = pads.find(pad => pad.color === color);\r\n  pad.sound.play();\r\n  checkPress(color);\r\n  return color;\r\n\r\n  // TODO: Write your code here.\r\n}\r\n\r\n/**\r\n * HELPER FUNCTIONS\r\n */\r\n\r\n/**\r\n * Sets the level of the game given a `level` parameter.\r\n * Returns the length of the sequence for a valid `level` parameter (1 - 4) or an error message otherwise.\r\n *\r\n * Each skill level will require the player to complete a different number of rounds, as follows:\r\n * Skill level 1: 8 rounds\r\n * Skill level 2: 14 rounds\r\n * Skill level 3: 20 rounds\r\n * Skill level 4: 31 rounds\r\n *\r\n *\r\n * Example:\r\n * setLevel() //> returns 8\r\n * setLevel(1) //> returns 8\r\n * setLevel(2) //> returns 14\r\n * setLevel(3) //> returns 20\r\n * setLevel(4) //> returns 31\r\n * setLevel(5) //> returns \"Please enter level 1, 2, 3, or 4\";\r\n * setLevel(8) //> returns \"Please enter level 1, 2, 3, or 4\";\r\n *\r\n */\r\nfunction setLevel(level = 1) {\r\n  // TODO: Write your code here.\r\n  if(level === 1 || level === 2 || level === 3 || level === 4){\r\n      if(level === 1)   return 8;\r\n      if(level === 2)   return 14;\r\n      if( level === 3)  return 20;\r\n      if( level === 4)  return 31;\r\n } else  return \"Please enter level 1, 2, 3, or 4\";\r\n}\r\n\r\n\r\n/**\r\n * Returns a randomly selected item from a given array.\r\n *\r\n * 1. `Math.random()` returns a floating-point, pseudo-random number in the range 0 to less than 1\r\n *\r\n * 2. Multiplying the value from `Math.random()` with the length of the array ensures that the range\r\n * of the random number is less than the length of the array. So if the length of the array is 4,\r\n * the random number returned will be between 0 and 4 (exclusive)\r\n *\r\n * 3. Math.floor() rounds the numbers down to the largest integer less than or equal the given value\r\n *\r\n * Example:\r\n * getRandomItem([1, 2, 3, 4]) //> returns 2\r\n * getRandomItem([1, 2, 3, 4]) //> returns 1\r\n */\r\nfunction getRandomItem(collection) {\r\n  if (collection.length === 0) return null;\r\n  const randomIndex = Math.floor(Math.random() * collection.length);\r\n  return collection[randomIndex];\r\n}\r\n\r\n/**\r\n * Sets the status text of a given HTML element with a given a message\r\n */\r\nfunction setText(element, text) {\r\n  // TODO: Write your code here.\r\n  element.textContent = text;\r\n  return element\r\n}\r\n\r\n/**\r\n * Activates a pad of a given color by playing its sound and light\r\n *\r\n * 1. Use the `.find()` method to retrieve the pad from the `pads` array and store it in\r\n * a variable called `pad`\r\n *\r\n * 2. Add the `\"activated\"` class to the selected pad\r\n *\r\n * 3. Play the sound associated with the pad\r\n *\r\n * 4. After 500ms, remove the `\"activated\"` class from the pad\r\n */\r\n\r\nfunction activatePad(color) {\r\n  // TODO: Write your code here.\r\n  const pad = pads.find((pad1) => pad1.color === color);\r\n  pad.selector.classList.add(\"activated\");\r\n  pad.sound.play();\r\n   setTimeout(() => {\r\n    pad.selector.classList.remove(\"activated\");\r\n  }, 500)\r\n}\r\n\r\n/**\r\n * Activates a sequence of colors passed as an array to the function\r\n *\r\n * 1. Iterate over the `sequence` array using `.forEach()`\r\n *\r\n * 2. For each element in `sequence`, use `setTimeout()` to call `activatePad()`, adding\r\n * a delay (in milliseconds) between each pad press. Without it, the pads in the sequence\r\n * will be activated all at once\r\n *\r\n * 3. The delay between each pad press, passed as a second argument to `setTimeout()`, needs\r\n * to change on each iteration. The first button in the sequence is activated after 600ms,\r\n * the next one after 1200ms (600ms after the first), the third one after 1800ms, and so on.\r\n */\r\n\r\nfunction activatePads(sequence) {\r\n  // TODO: Write your code here.\r\n  sequence.forEach((color, index) => { \r\n    setTimeout(() => {\r\n      activatePad(color)}, \r\n      (index + 1) * 600)\r\n  });\r\n}\r\n\r\n/**\r\n * Allows the computer to play its turn.\r\n *\r\n * 1. Add the `\"unclickable\"` class to `padContainer` to prevent the user from pressing\r\n * any of the pads\r\n *\r\n * 2. The status should display a message that says \"The computer's turn...\"\r\n *\r\n * 3. The heading should display a message that lets the player know how many rounds are left\r\n * (e.g., \"`Round ${roundCount} of ${maxRoundCount}`\")\r\n *\r\n * 4. Push a randomly selected color into the `computerSequence` array\r\n *\r\n * 5. Call `activatePads(computerSequence)` to light up each pad according to order defined in\r\n * `computerSequence`\r\n *\r\n * 6. The playHumanTurn() function needs to be called after the computer’s turn is over, so\r\n * we need to add a delay and calculate when the computer will be done with the sequence of\r\n * pad presses. The `setTimeout()` function executes `playHumanTurn(roundCount)` one second\r\n * after the last pad in the sequence is activated. The total duration of the sequence corresponds\r\n * to the current round (roundCount) multiplied by 600ms which is the duration for each pad in the\r\n * sequence.\r\n */\r\n function playComputerTurn() {\r\n  // TODO: Write your code here.\r\n  padContainer.classList.add(\"unclickable\")\r\n  \r\n  statusSpan.textContent = \"The computer's turn...\";\r\n  heading.textContent = `Round ${roundCount} of ${maxRoundCount}`;\r\n\r\n  const colors = [\"red\", \"green\", \"blue\", \"yellow\"];\r\n  const randomColor = getRandomItem(colors);\r\n\r\n  computerSequence.push(randomColor);\r\n  activatePads(computerSequence);\r\n\r\n  const delay = roundCount * 600 + 1000;\r\n  setTimeout(() => playHumanTurn(), delay); // 5\r\n\r\n}\r\n/**\r\n * Allows the player to play their turn.\r\n *\r\n * 1. Remove the \"unclickable\" class from the pad container so that each pad is clickable again\r\n *\r\n * 2. Display a status message showing the player how many presses are left in the round\r\n */\r\nfunction playHumanTurn() {\r\n  // TODO: Write your code here.\r\n  padContainer.classList.remove(\"unclickable\");\r\n  const remainingPresses = computerSequence.length - playerSequence.length;\r\n\r\n  setText( statusSpan, `player remaining presses: ${remainingPresses}`);\r\n}\r\n\r\n/**\r\n * Checks the player's selection every time the player presses on a pad during\r\n * the player's turn\r\n *\r\n * 1. Add the `color` variable to the end of the `playerSequence` array\r\n *\r\n * 2. Store the index of the `color` variable in a variable called `index`\r\n *\r\n * 3. Calculate how many presses are left in the round using\r\n * `computerSequence.length - playerSequence.length` and store the result in\r\n * a variable called `remainingPresses`\r\n *\r\n * 4. Set the status to let the player know how many presses are left in the round\r\n *\r\n * 5. Check whether the elements at the `index` position in `computerSequence`\r\n * and `playerSequence` match. If they don't match, it means the player made\r\n * a wrong turn, so call `resetGame()` with a failure message and exit the function\r\n *\r\n * 6. If there are no presses left (i.e., `remainingPresses === 0`), it means the round\r\n * is over, so call `checkRound()` instead to check the results of the round\r\n *\r\n */\r\nfunction checkPress(color) {\r\n  // TODO: Write your code here.\r\n  playerSequence.push(color);\r\n  const index = playerSequence.length -1;\r\n  if(playerSequence[index] !== computerSequence[index]){\r\n    resetGame(\"Wrong pad! Game over. Try again.\");\r\n    return;\r\n  }\r\n  const remainingPresses = computerSequence.length - playerSequence.length;\r\n  if(remainingPresses === 0) checkRound();\r\n  else statusSpan.textContent = `Player remaining presses: ${remainingPresses}`;\r\n\r\n}\r\n\r\n /**\r\n * Checks each round to see if the player has completed all the rounds of the game * or advance to the next round if the game has not finished.\r\n *\r\n * 1. If the length of the `playerSequence` array matches `maxRoundCount`, it means that\r\n * the player has completed all the rounds so call `resetGame()` with a success message\r\n *\r\n * 2. Else, the `roundCount` variable is incremented by 1 and the `playerSequence` array\r\n * is reset to an empty array.\r\n * - And the status text is updated to let the player know to keep playing (e.g., \"Nice! Keep going!\")\r\n * - And `playComputerTurn()` is called after 1000 ms (using setTimeout()). The delay\r\n * is to allow the user to see the success message. Otherwise, it will not appear at\r\n * all because it will get overwritten.\r\n *\r\n */\r\n\r\nfunction checkRound() {\r\n  // TODO: Write your code here.\r\n\r\n  if(roundCount === maxRoundCount) resetGame(\"Successfully you finished the game.\");\r\n  else{\r\n    roundCount++;\r\n    playerSequence = [];\r\n    setText(statusSpan, \"Nice! Keep going!\");\r\n    setTimeout(playComputerTurn, 1000)\r\n  }\r\n}\r\n\r\n/**\r\n * Resets the game. Called when either the player makes a mistake or wins the game.\r\n *\r\n * 1. Reset `computerSequence` to an empty array\r\n *\r\n * 2. Reset `playerSequence` to an empty array\r\n *\r\n * 3. Reset `roundCount` to an empty array\r\n */\r\nfunction resetGame(text) {\r\n  // TODO: Write your code here.\r\n  computerSequence = [];\r\n  playerSequence = [];\r\n  roundCount = 0;\r\n  // Uncomment the code below:\r\n  alert(text);\r\n  setText(heading, \"Simon Says\");\r\n  startButton.classList.remove(\"hidden\");\r\n  statusSpan.classList.add(\"hidden\");\r\n  padContainer.classList.add(\"unclickable\");\r\n}\r\n\r\n/**\r\n * Please do not modify the code below.\r\n * Used for testing purposes.\r\n *\r\n */\r\n\r\nwindow.statusSpan = statusSpan;\r\nwindow.heading = heading;\r\nwindow.padContainer = padContainer;\r\nwindow.pads = pads;\r\nwindow.computerSequence = computerSequence;\r\nwindow.playerSequence = playerSequence;\r\nwindow.maxRoundCount = maxRoundCount;\r\nwindow.roundCount = roundCount;\r\nwindow.startButtonHandler = startButtonHandler;\r\nwindow.padHandler = padHandler;\r\nwindow.setLevel = setLevel;\r\nwindow.getRandomItem = getRandomItem;\r\nwindow.setText = setText;\r\nwindow.activatePad = activatePad;\r\nwindow.activatePads = activatePads;\r\nwindow.playComputerTurn = playComputerTurn;\r\nwindow.playHumanTurn = playHumanTurn;\r\nwindow.checkPress = checkPress;\r\nwindow.checkRound = checkRound;\r\nwindow.resetGame = resetGame;"],"names":[],"version":3,"file":"js-dev-final-capstone-starter-simon-says.c36f364e.js.map","sourceRoot":"/__parcel_source_root/"}